#include "Plans/Attack/constraints/FreeZonePassing1508950989519Constraints.h"
using namespace std;
using namespace alica;
/*PROTECTED REGION ID(ch1508950989519) ENABLED START*/
#include <memory>

#include <AutoDiff.h>
#include <MSLConstraintBuilder.h>
#include <MSLFootballField.h>
#include <MSLWorldModel.h>
#include <engine/constraintmodul/ProblemDescriptor.h>
#include <engine/constraintmodul/SolverTerm.h>
#include <Ball.h>
#include <Robots.h>
/*PROTECTED REGION END*/

namespace alicaAutogenerated
{
// Plan:FreeZonePassing

/*
 * Tasks:
 * - EP:1508950989521 : DefaultTask (1225112227903)
 *
 * States:
 * - Passing (1508950989520)
 *
 * Vars:
 * - x (1508951697442)
 * - y (1508951702562)
 */

/*
 * RuntimeCondition - (Name): NewRuntimeCondition
 * (ConditionString):
 * Static Variables: [x, y]
 * Domain Variables:
 */
void Constraint1508951693560::getConstraint(shared_ptr<ProblemDescriptor> c, shared_ptr<RunningPlan> rp)
{
    /*PROTECTED REGION ID(cc1508951693560) ENABLED START*/
    double distanceToFieldBorder = 1000.0;
    double minPassDistance = 4000.0;
    double minDistanceToOpp = 1500.0;

    msl::MSLWorldModel *wm = msl::MSLWorldModel::get();
    shared_ptr<geometry::CNPoint2D> ballPose = wm->ball->getAlloBallPosition();
    shared_ptr<TVec> tvecBallPose = nullptr;
    if (ballPose)
    {
        tvecBallPose = make_shared<TVec>(initializer_list<double>{ballPose->x, ballPose->y});
    }

    // reduce area of possible solutions to an area inside the field with a distance of "distanceToFieldBorder" to the border
    c->getStaticRanges()->at(0).at(0) = wm->field->posLeftOwnCorner()->x + distanceToFieldBorder;
    c->getStaticRanges()->at(0).at(1) = wm->field->posLeftOppCorner()->x - distanceToFieldBorder;
    c->getStaticRanges()->at(1).at(0) = wm->field->posRightOwnCorner()->y + distanceToFieldBorder;
    c->getStaticRanges()->at(1).at(1) = wm->field->posLeftOwnCorner()->y - distanceToFieldBorder;

    shared_ptr<TVec> passPoint;

    auto constraint = autodiff::LTConstraint::TRUE;

    // not close to our own goal
    constraint = constraint & msl::MSLConstraintBuilder::outsideArea(msl::Areas::OwnPenaltyArea, passPoint, distanceToFieldBorder);

    // outside opponent goal area
    constraint = constraint & msl::MSLConstraintBuilder::outsideArea(msl::Areas::OppGoalArea, passPoint);

    // minimal pass distance
    if (ballPose)
    {
        constraint = constraint & msl::MSLConstraintBuilder::outsideSphere(tvecBallPose, minPassDistance, passPoint);
    }

    // initialize opponents for solver
    auto opps = wm->robots->opponents.getOpponentsAlloClustered();
    vector<shared_ptr<TVec>> oppsT;
    if (opps && !opps->empty())
    {

        for (auto &opp : *opps)
        {
            oppsT.push_back(make_shared<TVec>(initializer_list<double>{opp->x, opp->y}));
        }
    }

    // not close to an opponent
    constraint = constraint & msl::MSLConstraintBuilder::outsideSphere(passPoint, minDistanceToOpp, oppsT);

    // free pass corridor
    if (ballPose)
    {
//    constraint = constraint &
//                 msl::MSLConstraintBuilder::outsideTriangle(tvecBallPose, passPoint, 0.0, oppsT);
    //use konvex (yes with k) hull to cover corridor to pass point
    }

                     c->setConstraint(dynamic_pointer_cast<alica::SolverTerm>(constraint));
    /*PROTECTED REGION END*/
}

// State: Passing

// State: Passing
}
