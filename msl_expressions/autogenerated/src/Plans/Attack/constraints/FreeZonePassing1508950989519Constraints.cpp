#include "Plans/Attack/constraints/FreeZonePassing1508950989519Constraints.h"
using namespace std;
using namespace alica;
/*PROTECTED REGION ID(ch1508950989519) ENABLED START*/
#include <memory>

#include <AutoDiff.h>
#include <Ball.h>
#include <Constant.h>
#include <MSLConstraintBuilder.h>
#include <MSLFootballField.h>
#include <MSLWorldModel.h>
#include <RawSensorData.h>
#include <Robots.h>
#include <Rules.h>
#include <engine/constraintmodul/ProblemDescriptor.h>
#include <engine/constraintmodul/SolverTerm.h>
/*PROTECTED REGION END*/

namespace alicaAutogenerated
{
// Plan:FreeZonePassing

/*
 * Tasks:
 * - EP:1508950989521 : DefaultTask (1225112227903)
 *
 * States:
 * - Passing (1508950989520)
 *
 * Vars:
 * - x (1508951697442)
 * - y (1508951702562)
 */

/*
 * RuntimeCondition - (Name): NewRuntimeCondition
 * (ConditionString):
 * Static Variables: [x, y]
 * Domain Variables:
 */
void Constraint1508951693560::getConstraint(shared_ptr<ProblemDescriptor> c, shared_ptr<RunningPlan> rp)
{
    /*PROTECTED REGION ID(cc1508951693560) ENABLED START*/
    double distanceToFieldBorder = 1000.0;
    double minPassDistance = 4000.0;
    double minDistanceToOpp = 1500.0;

    msl::MSLWorldModel *wm = msl::MSLWorldModel::get();
    shared_ptr<geometry::CNPoint2D> ballPose = wm->ball->getAlloBallPosition();
    shared_ptr<geometry::CNPosition> ownPos = wm->rawSensorData->getOwnPositionVision();
    if (!ownPos)
    {
        auto constraint = autodiff::LTConstraint::FALSE;
        c->setConstraint(dynamic_pointer_cast<alica::SolverTerm>(constraint));
        return;
    }
    shared_ptr<TVec> tvecBallPose = nullptr;
    if (ballPose)
    {
        tvecBallPose = make_shared<TVec>(initializer_list<double>{ballPose->x, ballPose->y});
    }

    // reduce area of possible solutions to an area inside the field with a distance of "distanceToFieldBorder" to the border
    c->getStaticRanges()->at(0).at(0) = wm->field->posLeftOwnCorner()->x + distanceToFieldBorder;
    c->getStaticRanges()->at(0).at(1) = wm->field->posLeftOppCorner()->x - distanceToFieldBorder;
    c->getStaticRanges()->at(1).at(0) = wm->field->posRightOwnCorner()->y + distanceToFieldBorder;
    c->getStaticRanges()->at(1).at(1) = wm->field->posLeftOwnCorner()->y - distanceToFieldBorder;

    shared_ptr<TVec> passPoint;

    auto constraint = autodiff::LTConstraint::TRUE;

    // not close to our own goal
    constraint = constraint & msl::MSLConstraintBuilder::outsideArea(msl::Areas::OwnPenaltyArea, passPoint, distanceToFieldBorder);

    // outside opponent goal area
    constraint = constraint & msl::MSLConstraintBuilder::outsideArea(msl::Areas::OppGoalArea, passPoint);

    // minimal pass distance
    if (ballPose)
    {
        constraint = constraint & msl::MSLConstraintBuilder::outsideSphere(tvecBallPose, minPassDistance, passPoint);
    }

    // initialize opponents for solver
    auto opps = wm->robots->opponents.getOpponentsAlloClustered();
    vector<shared_ptr<TVec>> oppsT;
    if (opps && !opps->empty())
    {
        for (auto &opp : *opps)
        {
            oppsT.push_back(make_shared<TVec>(initializer_list<double>{opp->x, opp->y}));
        }
    }

    // not close to an opponent
    constraint = constraint & msl::MSLConstraintBuilder::outsideSphere(passPoint, minDistanceToOpp, oppsT);

    // free pass corridor
    if (ballPose)
    {
        vector<shared_ptr<TVec>> trapezium;
        // ball + extra + robotradius == 2* robotradius
        // Lower right corner
        shared_ptr<geometry::CNPoint2D> lrPos = make_shared<geometry::CNPoint2D>(0.0, 2 * msl::Rules::getInstance()->getRobotRadius());
        lrPos = lrPos->egoToAllo(*ownPos);
        shared_ptr<TVec> tvecLRPos = make_shared<TVec>(initializer_list<double>{lrPos->x, lrPos->y});
        trapezium.push_back(tvecLRPos);

        // helping vectors
        shared_ptr<TVec> tvecOwnPos = make_shared<TVec>(initializer_list<double>{ownPos->x, ownPos->y});
        shared_ptr<TVec> passPointVec = (passPoint - tvecOwnPos);
        shared_ptr<TVec> robotSizeVec = (tvecLRPos - tvecOwnPos);

        //upper right corner
        shared_ptr<TVec> urPos = (passPointVec + robotSizeVec) * 1.5;
        trapezium.push_back(urPos);
        //upper left corner
        shared_ptr<TVec> ulPos = (passPointVec - robotSizeVec) * 1.5;
        trapezium.push_back(ulPos);

        // Lower left corner
        shared_ptr<geometry::CNPoint2D> llPos = make_shared<geometry::CNPoint2D>(0.0, 2 * -msl::Rules::getInstance()->getRobotRadius());
        llPos = llPos->egoToAllo(*ownPos);
        shared_ptr<TVec> tvecLLPos = make_shared<TVec>(initializer_list<double>{llPos->x, llPos->y});
        trapezium.push_back(tvecLLPos);
        constraint = constraint & msl::MSLConstraintBuilder::outsideConvex(trapezium, 0.0, oppsT);
    }

    c->setConstraint(dynamic_pointer_cast<alica::SolverTerm>(constraint));
    /*PROTECTED REGION END*/
}

// State: Passing

// State: Passing
}
